{
  "language": "Solidity",
  "sources": {
    "contracts/Distribution/USDRetriever.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract USDRetriever {\n    IERC20 internal USDCContract;\n\n    event ReceivedTokens(address indexed from, uint256 amount);\n    event TransferTokens(address indexed to, uint256 amount);\n    event ApproveTokens(address indexed to, uint256 amount);\n\n    function setUSDToken(address _usdContractAddress) internal {\n        USDCContract = IERC20(_usdContractAddress);\n    }\n\n    function approveTokens(address _to, uint256 _amount) internal {\n        USDCContract.approve(_to, _amount);\n        emit ApproveTokens(_to, _amount);\n    }\n\n    function getUSDBalance() external view returns (uint256) {\n        return USDCContract.balanceOf(address(this));\n    }\n\n    function getUSDToken() external view returns (address) {\n        return address(USDCContract);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/Staking/StakingPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../Role/PoolCreator.sol\";\nimport \"./StakingPoolProxy.sol\";\nimport \"../interfaces/IRewardManager.sol\";\nimport \"../Distribution/USDRetriever.sol\";\n\ncontract StakingPoolFactory is PoolCreator {\n    ITotemToken public totemToken;\n    IRewardManager public rewardManager;\n\n    address public superAdmin;\n    address public stakingPoolImplementationAdr;\n    address public swapRouter;\n    address public usdToken;\n    uint256 public stakingPoolTaxRate;\n    uint256 public minimumStakeAmount;\n\n    /**\n     * @param variables The StakingPoolProxy is created with these specs:\n            variables[0] = launchDate\n            variables[1] = maturityTime\n            variables[2] = lockTime\n            variables[3] = sizeAllocation\n            variables[4] = stakeApr\n            variables[5] = prizeAmount\n            variables[6] = usdPrizeAmount\n            variables[7] = potentialCollabReward\n            variables[8] = collaborativeRange\n            variables[9] = stakingPoolTaxRate\n            variables[10] = minimumStakeAmount\n            variables[11] = oracleDeciamls\n     */\n    event PoolCreated(\n        address indexed pool,\n        string wrappedTokenSymbol,\n        string poolType,\n        uint256[12] variables,\n        uint256[8] ranks,\n        uint256[8] percentages,\n        bool isEnhancedEnabled\n    );\n\n    event NewStakingPoolImplemnetationWasSet();\n\n    event NewSuperAdminWasSet();\n\n    constructor (\n        ITotemToken _totemToken,\n        IRewardManager _rewardManager,\n        address _swapRouter,\n        address _usdToken,\n        address _stakingPoolImplementation,\n        address _superAdmin\n    ){\n        totemToken = _totemToken;\n        rewardManager = _rewardManager;\n        swapRouter = _swapRouter;\n        usdToken = _usdToken;\n        stakingPoolImplementationAdr = _stakingPoolImplementation;\n        superAdmin = _superAdmin;\n         \n        stakingPoolTaxRate = 300;\n    }\n\n    /**\n     * @notice creates a StakingPoolProxy for the  provided stakingPoolImplementationAdr\n            and initializes it so that the pool is ready to be used.\n       @param _variables The StakingPoolProxy is created with these specs:\n            variables[0] = launchDate\n            variables[1] = maturityTime\n            variables[2] = lockTime\n            variables[3] = sizeAllocation\n            variables[4] = stakeApr\n            variables[5] = prizeAmount\n            variables[6] = usdPrizeAmount\n            variables[7] = potentialCollabReward\n            variables[8] = collaborativeRange\n            variables[9] = stakingPoolTaxRate\n            variables[10] = minimumStakeAmount\n            variables[11] = oracleDeciamls\n    */\n    function createPoolProxy(\n        address _oracleContract,\n        address _wrappedTokenContract,\n        string memory _wrappedTokenSymbol,\n        string memory _poolType,\n        uint256[12] memory _variables,\n        uint256[8] memory _ranks,\n        uint256[8] memory _percentages,\n        bool isEnhancedEnabled\n    ) external onlyPoolCreator returns (address) {\n        \n        require(\n            _ranks.length == _percentages.length,\n            \"length of ranks and percentages should be same\"\n        );\n\n        if (_variables[9] == 0) {\n            _variables[9] = stakingPoolTaxRate;\n        }\n\n        StakingPoolProxy stakingPoolProxy = new StakingPoolProxy();\n        address stakingPoolProxyAdr = address(stakingPoolProxy);\n\n        stakingPoolProxy.upgradeTo(stakingPoolImplementationAdr);\n\n        address[4] memory addrs = [swapRouter, usdToken, _oracleContract, _wrappedTokenContract];\n\n        _createPool( \n            addrs, \n            _wrappedTokenSymbol, \n            _poolType, \n            _variables, \n            _ranks, \n            _percentages, \n            isEnhancedEnabled,\n            stakingPoolProxy\n        );\n\n        stakingPoolProxy.transferOwnership(superAdmin);\n\n        rewardManager.addPool(stakingPoolProxyAdr);\n\n        return stakingPoolProxyAdr;\n    }\n\n    function _createPool(\n        address[4] memory _addrs,\n        string memory _wrappedTokenSymbol,\n        string memory _poolType,\n        uint256[12] memory _variables,\n        uint256[8] memory _ranks,\n        uint256[8] memory _percentages,\n        bool _isEnhancedEnabled,\n        StakingPoolProxy _stakingPoolProxy\n    ) internal {\n        _stakingPoolProxy.initialize(\n            _wrappedTokenSymbol,\n            _poolType,\n            totemToken,\n            rewardManager,\n            _msgSender(),\n            _addrs,\n            _variables,\n            _ranks,\n            _percentages,\n            _isEnhancedEnabled\n        );\n\n        address stakingPoolProxyAdr = address(_stakingPoolProxy);\n\n        emit PoolCreated(\n            stakingPoolProxyAdr,\n            _wrappedTokenSymbol,\n            _poolType,\n            _variables,\n            _ranks,\n            _percentages,\n            _isEnhancedEnabled\n        );\n    }\n\n    /**\n     * @notice This function is called whenever we want to use a new StakingPoolImplementation\n            to create our proxies for.\n     * @param _ImpAdr address of the new StakingPoolImplementation contract.\n    */\n    function setNewStakingPoolImplementationAdr(address _ImpAdr) external onlyPoolCreator {\n        require(\n            stakingPoolImplementationAdr != _ImpAdr, \n            'This address is the implementation that is already being used'\n        );\n        stakingPoolImplementationAdr = _ImpAdr;\n        emit NewStakingPoolImplemnetationWasSet();\n    }\n\n    /**\n     * @notice Changes superAdmin's address so that new StakingPoolProxies have this new superAdmin\n    */\n    function setNewSuperAdmin(address _superAdmin) external onlyPoolCreator {\n        superAdmin = _superAdmin;\n        emit NewSuperAdminWasSet();\n    }\n\n    function setSwapRouter(address _swapRouter) external onlyPoolCreator {\n        require(_swapRouter != address(0), \"0410\");\n        swapRouter = _swapRouter;\n    }\n\n    function setDefaultTaxRate(uint256 newStakingPoolTaxRate)\n        external\n        onlyPoolCreator\n    {\n        require(\n            newStakingPoolTaxRate < 10000,\n            \"0420 Tax connot be over 100% (10000 BP)\"\n        );\n        stakingPoolTaxRate = newStakingPoolTaxRate;\n    }\n}"
    },
    "contracts/Role/PoolCreator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"./Roles.sol\";\n\ncontract PoolCreator is Context {\n    using Roles for Roles.Role;\n\n    event PoolCreatorAdded(address indexed account);\n    event PoolCreatorRemoved(address indexed account);\n\n    Roles.Role private _poolCreators;\n\n    constructor() {\n        if (!isPoolCreator(_msgSender())) {\n            _addPoolCreator(_msgSender());\n        }\n    }\n\n    modifier onlyPoolCreator() {\n        require(\n            isPoolCreator(_msgSender()),\n            \"PoolCreatorRole: caller does not have the PoolCreator role\"\n        );\n        _;\n    }\n\n    function isPoolCreator(address account) public view returns (bool) {\n        return _poolCreators.has(account);\n    }\n\n    function addPoolCreator(address account) public onlyPoolCreator {\n        _addPoolCreator(account);\n    }\n\n    function renouncePoolCreator() public {\n        _removePoolCreator(_msgSender());\n    }\n\n    function _addPoolCreator(address account) internal {\n        _poolCreators.add(account);\n        emit PoolCreatorAdded(account);\n    }\n\n    function _removePoolCreator(address account) internal {\n        _poolCreators.remove(account);\n        emit PoolCreatorRemoved(account);\n    }\n}\n"
    },
    "contracts/Staking/StakingPoolProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./StakingPoolStorageStructure.sol\";\n\ncontract StakingPoolProxy is StakingPoolStorageStructure {\n    using BasisPoints for uint256;\n    using SafeMath for uint256;\n\n    modifier onlyPoolCreator() {\n        require(msg.sender == poolCreator, \"msg.sender is not an owner\");\n        _;\n    }\n\n    event ImplementationUpgraded();\n\n    /**\n     * @dev poolCreator is set to the address of StakingPoolFactory here, but it will change\n            to the address of the owner after initialize is called. This is to prevent any other\n            entity other than the StakingPoolFactory to call initialize and upgradeTo (for the \n            first time).\n            upgradeEnabled set to true so that upgradeTo can be called for the first time\n            when the main impelementaiton is being set. \n    */\n    constructor() {\n        poolCreator = msg.sender;\n        upgradeEnabled = true;\n    }\n\n    /**\n     * @notice This is called in case we want to upgrade a working pool which inherits from\n            the original implementation, to apply bug fixes and consider emergency cases.\n    */\n    function upgradeTo(address _newStakingPoolImplementation)\n        external\n        onlyPoolCreator\n    {\n        require(upgradeEnabled, \"Upgrade is not enabled yet\");\n        require(\n            stakingPoolImplementation != _newStakingPoolImplementation,\n            \"Is already the implementation\"\n        );\n        _setStakingPoolImplementation(_newStakingPoolImplementation);\n        upgradeEnabled = false;\n    }\n\n    /**\n     * @notice StakingPoolImplementation can't be upgraded unless superAdmin sets upgradeEnabled\n     */\n    function enableUpgrade() external onlyOwner {\n        upgradeEnabled = true;\n    }\n\n    function disableUpgrade() external onlyOwner {\n        upgradeEnabled = false;\n    }\n\n    /**\n     * @notice The initializer modifier is used to make sure initialize() is not called \n            more than once because we want it to act like a constructor.\n       @param _addrs Addresses used by priceConsumer and WrappedTokenDistributor\n                _addrs[0] = swapRouterAddress\n                _addrs[1] = BUSDContractAddress\n                _addrs[2] = OracleAddress\n                _addrs[3] = WrappedTokenContractAddress\n    */\n\n    // TODO: gas optimization required\n    function initialize(\n        string memory _wrappedTokenSymbol,\n        string memory _poolType,\n        ITotemToken _totemToken,\n        IRewardManager _rewardManager,\n        address _poolCreator,\n        address[4] memory _addrs,\n        uint256[12] memory _variables,\n        uint256[8] memory _ranks,\n        uint256[8] memory _percentages,\n        bool _isEnhancedEnabled\n    ) public initializer onlyPoolCreator {\n        /// @dev we should call inits because we don't have a constructor to do it for us\n        OwnableUpgradeable.__Ownable_init();\n        ContextUpgradeable.__Context_init();\n\n        WrappedTokenDistributorUpgradeable.__WrappedTokenDistributor_initialize(\n                _addrs[0],\n                _addrs[1],\n                _addrs[3]\n            );\n\n        require(\n            _variables[0] > block.timestamp,\n            \"0301 launch date can't be in the past\"\n        );\n\n        wrappedTokenSymbol = _wrappedTokenSymbol;\n        poolType = _poolType;\n        totemToken = _totemToken;\n        rewardManager = _rewardManager;\n        poolCreator = _poolCreator;\n        setUSDToken(_addrs[1]);\n        oracleContract = _addrs[2];\n        wrappedToken = IERC20(_addrs[3]);\n\n        launchDate = _variables[0];\n        maturityTime = _variables[1];\n        lockTime = _variables[2];\n        sizeAllocation = _variables[3];\n        stakeApr = _variables[4];\n        prizeAmount = _variables[5];\n        usdPrizeAmount = _variables[6];\n        potentialCollabReward = _variables[7];\n        collaborativeRange = _variables[8];\n        stakeTaxRate = _variables[9];\n        minimumStakeAmount = _variables[10];\n\n        if (_addrs[2] == address(0)) oracleDecimals = _variables[11];\n        else oracleDecimals = PriceConsumer.getDecimals(oracleContract);\n\n        isEnhancedEnabled = _isEnhancedEnabled;\n\n        // ranks validation\n        uint256 rewardRates = _ranks[0].mul(_percentages[0]);\n        uint256 l;\n        for (l = 0; l < _ranks.length; l++) {\n            if (_ranks[l] == 0) break;\n\n            if (_ranks[l + 1] != 0) {\n                require(_ranks[l] < _ranks[l + 1], \"wrong order of ranks\");\n                rewardRates = rewardRates.add(\n                    (_ranks[l + 1].sub(_ranks[l])).mul(_percentages[l + 1])\n                );\n            }\n\n            prizeRewardRates.push(\n                PrizeRewardRate({rank: _ranks[l], percentage: _percentages[l]})\n            );\n        }\n\n        require(\n            _ranks[l - 1] <= 25,\n            \"last rank must be less than or equal to 25\"\n        );\n\n        require(\n            _percentages[l - 1] != 0 && _percentages[l] == 0,\n            \"ranks and percentages length mismatch\"\n        );\n\n        require(rewardRates == 10000, \"reward percentages must be 100%\");\n\n        /**\n         * @notice LibParams are set here. Some of them may change in the lifetime of a pool\n                which is also considered\n        */\n        lps.launchDate = launchDate;\n        lps.lockTime = lockTime;\n        lps.maturityTime = maturityTime;\n        lps.usdPrizeAmount = usdPrizeAmount;\n        lps.prizeAmount = prizeAmount;\n        lps.stakeApr = stakeApr;\n        lps.collaborativeReward = collaborativeReward;\n        lps.isEnhancedEnabled = isEnhancedEnabled;\n    }\n\n    fallback() external payable {\n        address opr = stakingPoolImplementation;\n        require(opr != address(0));\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), opr, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n\n    function _setStakingPoolImplementation(address _newStakingPool) internal {\n        stakingPoolImplementation = _newStakingPool;\n        emit ImplementationUpgraded();\n    }\n}\n"
    },
    "contracts/interfaces/IRewardManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface IRewardManager {\n\n    function setOperator(address _newOperator) external;\n\n    function addPool(address _poolAddress) external;\n\n    function rewardUser(address _user, uint256 _amount) external;\n\n    event SetOperator(address operator);\n    event SetRewarder(address rewarder);\n\n}"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/Role/Roles.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping(address => bool) bearer;\n    }\n\n    /**\n     * @dev Give an account access to this role.\n     */\n    function add(Role storage role, address account) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev Remove an account's access to this role.\n     */\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev Check if an account has this role.\n     * @return bool\n     */\n    function has(Role storage role, address account)\n        internal\n        view\n        returns (bool)\n    {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return role.bearer[account];\n    }\n}\n"
    },
    "contracts/Staking/StakingPoolStorageStructure.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../Distribution/USDRetriever.sol\";\nimport \"../Distribution/WrappedTokenDistributorUpgradeable.sol\";\n\nimport \"../libraries/BasisPoints.sol\";\nimport \"../libraries/CalculateRewardLib.sol\";\nimport \"../libraries/IndexedClaimRewardLib.sol\";\nimport \"../libraries/ClaimRewardLib.sol\";\nimport \"../libraries/PriceConsumer.sol\";\n\nimport \"../interfaces/ITotemToken.sol\";\nimport \"../interfaces/IRewardManager.sol\";\n\ncontract StakingPoolStorageStructure is\n    OwnableUpgradeable,\n    USDRetriever,\n    WrappedTokenDistributorUpgradeable\n{\n    /**\n     * @notice Declared for passing the needed params to libraries.\n     */\n    struct LibParams {\n        uint256 launchDate;\n        uint256 lockTime;\n        uint256 maturityTime;\n        uint256 maturingPrice;\n        uint256 usdPrizeAmount;\n        uint256 prizeAmount;\n        uint256 stakeApr;\n        uint256 collaborativeReward;\n        uint256 oracleDecimals;\n        bool isEnhancedEnabled;\n        bool isMatured;\n    }\n\n    struct StakeWithPrediction {\n        uint256 stakedBalance;\n        uint256 stakedTime;\n        uint256 amountWithdrawn;\n        uint256 lastWithdrawalTime;\n        uint256 pricePrediction;\n        uint256 difference;\n        uint256 rank;\n        bool prizeRewardWithdrawn;\n        bool didUnstake;\n    }\n\n    struct Staker {\n        address stakerAddress;\n        uint256 index;\n    }\n\n    struct PrizeRewardRate {\n        uint256 rank;\n        uint256 percentage;\n    }\n\n    uint256 public constant sizeLimitRangeRate = 5;\n\n    uint256 public launchDate;\n    uint256 public lockTime;\n    uint256 public maturityTime;\n    uint256 public sizeAllocation;\n    uint256 public stakeApr;\n    uint256 public prizeAmount;\n    /**\n     * @notice usdPrizeAmount is the enabler of WrappedToken rewarder; If it is set to 0 \n            then the pool is only TOTM rewarder.\n     */\n    uint256 public usdPrizeAmount;\n    uint256 public stakeTaxRate;\n    uint256 public minimumStakeAmount;\n    uint256 public totalStaked;\n    uint256 public maturingPrice;\n    uint256 public potentialCollabReward;\n    uint256 public collaborativeRange;\n    /**\n     * @notice Based on the white paper, the collaborative reward can be 20% (2000),\n             25% (2500) or 35% (3500).\n     */\n    uint256 public collaborativeReward;\n    uint256 public oracleDecimals;\n    uint256 public averagePricePrediction;\n\n    address public stakingPoolImplementation;\n    address public poolCreator;\n    address public oracleContract;\n\n    bool public isAnEmergency;\n    bool public isEnhancedEnabled;\n    bool public isActive;\n    bool public isLocked;\n    bool public isMatured;\n    bool public isDeleted;\n    /**\n     * @dev StakingPoolImplementation can't be upgraded unless superAdmin sets this flag.\n     */\n    bool public upgradeEnabled;\n\n    string public wrappedTokenSymbol;\n    string public poolType;\n\n    LibParams public lps;\n\n    PrizeRewardRate[] public prizeRewardRates;\n    Staker[] public stakers;\n    Staker[] public sortedStakers;\n\n    mapping(address => StakeWithPrediction[]) public predictions;\n\n    ITotemToken public totemToken;\n    IRewardManager public rewardManager;\n    IERC20 public wrappedToken;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/Distribution/WrappedTokenDistributorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"../interfaces/IPancakeRouter.sol\";\n\ncontract WrappedTokenDistributorUpgradeable is Initializable{\n    IPancakeRouter02 internal swapRouter;\n    address internal BUSD_CONTRACT_ADDRESS;\n    address internal WRAPPED_Token_CONTRACT_ADDRESS;\n\n    event DistributedBTC(address indexed to, uint256 amount);\n\n    function __WrappedTokenDistributor_initialize(\n        address swapRouterAddress,\n        address BUSDContractAddress,\n        address WrappedTokenContractAddress\n    ) public initializer {\n        swapRouter = IPancakeRouter02(swapRouterAddress);\n        BUSD_CONTRACT_ADDRESS = BUSDContractAddress;\n        WRAPPED_Token_CONTRACT_ADDRESS = WrappedTokenContractAddress;\n    }\n\n    /**\n     * @param _to Reciever address\n     * @param _usdAmount USD Amount\n     * @param _wrappedTokenAmount Wrapped Token Amount\n     */\n    function transferTokensThroughSwap(\n        address _to,\n        uint256 _usdAmount,\n        uint256 _wrappedTokenAmount,\n        uint256 _deadline\n    ) internal {\n        require(_to != address(0));\n        // Get max USD price we can spend for this amount.\n        swapRouter.swapExactTokensForTokens(\n            _usdAmount,\n            _wrappedTokenAmount,\n            getPathForUSDToWrappedToken(),\n            _to,\n            _deadline\n        );\n    }\n\n    /**\n     * @param _amount Amount\n     */\n    function getEstimatedWrappedTokenForUSD(uint256 _amount)\n        public\n        view\n        returns (uint256)\n    {\n        uint256[] memory wrappedTokenAmount =\n            swapRouter.getAmountsOut(_amount, getPathForUSDToWrappedToken());\n        // since in the path the wrappedToken is the second one, so we should retuen the second one also here    \n        return wrappedTokenAmount[1];\n    }\n\n    function getPathForUSDToWrappedToken() public view returns (address[] memory) {\n        address[] memory path = new address[](2);\n        path[0] = BUSD_CONTRACT_ADDRESS;\n        path[1] = WRAPPED_Token_CONTRACT_ADDRESS;\n\n        return path;\n    }\n\n    function getSwapRouter() public view returns (address) {\n        return address(swapRouter);\n    }\n}\n"
    },
    "contracts/libraries/BasisPoints.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary BasisPoints {\n    using SafeMath for uint256;\n\n    uint256 private constant BASIS_POINTS = 10000;\n\n    function mulBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n        return amt.mul(bp).div(BASIS_POINTS);\n    }\n\n    function divBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n        require(bp > 0, \"Cannot divide by zero.\");\n        return amt.mul(BASIS_POINTS).div(bp);\n    }\n\n    function addBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n        if (amt == 0) return 0;\n        if (bp == 0) return amt;\n        return amt.add(mulBP(amt, bp));\n    }\n\n    function subBP(uint256 amt, uint256 bp) internal pure returns (uint256) {\n        if (amt == 0) return 0;\n        if (bp == 0) return amt;\n        return amt.sub(mulBP(amt, bp));\n    }\n}\n"
    },
    "contracts/libraries/CalculateRewardLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"../libraries/BasisPoints.sol\";\nimport \"../Staking/StakingPoolStorageStructure.sol\";\n\nlibrary CalculateRewardLib {\n\n    using BasisPoints for uint256;\n    using SafeMath for uint256;\n\n    uint256 public constant foo = 0;\n\n    function getTotalStakedBalance(StakingPoolStorageStructure.StakeWithPrediction[] storage _staker)\n        public\n        view\n        returns (uint256)\n    {\n        if (_staker.length == 0) return 0;\n\n        uint256 totalStakedBalance = 0;\n        for (uint256 i = 0; i < _staker.length; i++) {\n            if (!_staker[i].didUnstake) {\n                totalStakedBalance = totalStakedBalance.add(\n                    _staker[i].stakedBalance\n                );\n            }\n        }\n\n        return totalStakedBalance;\n    }\n\n    /**\n     * @notice the reward formula is:\n          ((1 + stakeAPR +enhancedReward)^((MaturingDate - StakingDate)/365) - 1) * StakingBalance\n    */\n    function _getStakingRewardPerStake(\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \n        uint256 _stakeIndex,\n        StakingPoolStorageStructure.LibParams storage _lps\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 maturityDate = \n            _lps.launchDate + \n            _lps.lockTime + \n            _lps.maturityTime;\n\n        uint256 timeTo =\n            block.timestamp > maturityDate ? maturityDate : block.timestamp;\n\n        uint256 enhancedApr;\n        if ( _lps.isEnhancedEnabled ) {\n            enhancedApr = _getEnhancedRewardRate(\n                _staker[_stakeIndex].stakedTime,\n                _lps\n            );\n        }\n\n        uint256 rewardPerStake = _calcStakingReturn(\n            _lps.stakeApr.add(enhancedApr),\n            timeTo.sub(_staker[_stakeIndex].stakedTime),\n            _staker[_stakeIndex].stakedBalance\n        );\n\n        rewardPerStake = rewardPerStake.sub(_staker[_stakeIndex].amountWithdrawn);\n\n        return rewardPerStake;\n    }\n\n    function _getEnhancedRewardRate(\n        uint256 stakedTime,\n        StakingPoolStorageStructure.LibParams storage _lps\n    )\n        internal\n        view\n        returns (uint256)\n    {\n\n        if (!_lps.isEnhancedEnabled) {\n            return 0;\n        }\n\n        uint256 lockDate = _lps.launchDate.add(_lps.lockTime);\n        uint256 difference = lockDate.sub(stakedTime);\n\n        if (difference < 48 hours) {\n            return 0;\n        } else if (difference < 72 hours) {\n            return 100;\n        } else if (difference < 96 hours) {\n            return 200;\n        } else if (difference < 120 hours) {\n            return 300;\n        } else if (difference < 144 hours) {\n            return 400;\n        } else {\n            return 500;\n        }\n    }\n\n    function _calcStakingReturn(uint256 totalRewardRate, uint256 timeDuration, uint256 totalStakedBalance) \n        internal \n        pure\n        returns (uint256) \n    {\n        uint256 yearInSeconds = 365 days;\n\n        uint256 first = (yearInSeconds**2)\n            .mul(10**8);\n\n        uint256 second = timeDuration\n            .mul(totalRewardRate) \n            .mul(yearInSeconds)\n            .mul(5000);\n        \n        uint256 third = totalRewardRate\n            .mul(yearInSeconds**2)\n            .mul(5000);\n\n        uint256 forth = (timeDuration**2)\n            .mul(totalRewardRate**2)\n            .div(6);\n\n        uint256 fifth = timeDuration\n            .mul(totalRewardRate**2)\n            .mul(yearInSeconds)\n            .div(2);\n\n        uint256 sixth = (totalRewardRate**2)\n            .mul(yearInSeconds**2)\n            .div(3);\n \n        uint256 rewardPerStake = first.add(second).add(forth).add(sixth);\n\n        rewardPerStake = rewardPerStake.sub(third).sub(fifth);\n\n        rewardPerStake = rewardPerStake\n            .mul(totalRewardRate)\n            .mul(timeDuration);\n\n        rewardPerStake = rewardPerStake\n            .mul(totalStakedBalance)\n            .div(yearInSeconds**3)\n            .div(10**12);\n\n        return rewardPerStake; \n    }\n\n    function _getPercentageReward(\n        uint256 _rank, \n        StakingPoolStorageStructure.PrizeRewardRate[] storage _prizeRewardRates\n    )\n        internal\n        view\n        returns (uint256)\n    {\n        for (uint256 i = 0; i < _prizeRewardRates.length; i++) {\n            if (_rank <= _prizeRewardRates[i].rank) {\n                return _prizeRewardRates[i].percentage;\n            }\n        }\n\n        return 0;\n    }        \n\n\n\n}"
    },
    "contracts/libraries/IndexedClaimRewardLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./CalculateRewardLib.sol\";\nimport \"../libraries/BasisPoints.sol\";\nimport \"../Staking/StakingPoolStorageStructure.sol\";\n\nlibrary IndexedClaimRewardLib {\n\n    using CalculateRewardLib for *;\n    using BasisPoints for uint256; \n    using SafeMath for uint256;\n\n    uint256 public constant foo = 0;\n\n    function withdrawIndexedStakingReturn(\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \n        uint256 _stakeIndex,\n        StakingPoolStorageStructure.LibParams storage _lps\n    ) \n        public\n    {\n        if (_staker.length == 0) return;\n        if (_stakeIndex >= _staker.length) return;\n\n        uint256 rewardPerStake = CalculateRewardLib._getStakingRewardPerStake(\n            _staker, \n            _stakeIndex,\n            _lps\n        );\n\n        _staker[_stakeIndex].lastWithdrawalTime = block.timestamp;\n        _staker[_stakeIndex].amountWithdrawn = _staker[_stakeIndex].amountWithdrawn.add(\n            rewardPerStake\n        );\n    }\n\n    function withdrawIndexedPrize(\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \n        uint256 _stakeIndex\n    ) \n        public \n    {\n        if (_staker.length == 0) return;\n        if (_staker[_stakeIndex].prizeRewardWithdrawn) return;\n\n        _staker[_stakeIndex].prizeRewardWithdrawn = true;\n    }\n\n    function withdrawIndexedStakedBalance(\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \n        uint256 _stakeIndex\n    ) \n        public\n    {\n        if (_staker.length == 0) return;\n        if (_stakeIndex >= _staker.length) return;\n\n        _staker[_stakeIndex].didUnstake = true;\n    }\n\n    function getIndexedStakedBalance(\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \n        uint256 _stakeIndex\n    )\n        public\n        view\n        returns (uint256)\n    {\n        if (_staker.length == 0) return 0;\n        if (_stakeIndex >= _staker.length) return 0; \n\n        uint256 totalStakedBalance = 0;\n\n        if (!_staker[_stakeIndex].didUnstake) {\n            totalStakedBalance = totalStakedBalance.add(\n                _staker[_stakeIndex].stakedBalance\n            );\n        }\n\n        return totalStakedBalance;\n    }\n\n    function getIndexedStakingReturn(\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \n        uint256 _stakeIndex,\n        StakingPoolStorageStructure.LibParams storage _lps\n    ) \n        public\n        view \n        returns (uint256) \n    {\n        if (_staker.length == 0) return 0;\n        if (_stakeIndex >= _staker.length) return 0;\n\n        uint256 reward = 0;\n        \n        uint256 rewardPerStake = CalculateRewardLib._getStakingRewardPerStake(\n            _staker, \n            _stakeIndex,\n            _lps\n        );\n        reward = reward.add(rewardPerStake);\n\n        return reward;\n    }\n\n    function getIndexedPrize(\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \n        uint256 _stakeIndex,\n        StakingPoolStorageStructure.LibParams storage _lps,\n        StakingPoolStorageStructure.PrizeRewardRate[] storage _prizeRewardRates\n    )\n        public\n        view\n        returns (uint256, uint256)\n    {\n        if (!_lps.isMatured) return (0, 0);\n\n        if (_staker.length == 0) return (0, 0);\n\n        if (_stakeIndex >= _staker.length) return (0,0);\n\n        if (_staker[_stakeIndex].prizeRewardWithdrawn) return (0, 0);\n\n        uint256 maturingWrappedTokenPrizeAmount =\n            (_lps.usdPrizeAmount.mul(10**_lps.oracleDecimals)).div(_lps.maturingPrice);\n\n        uint256 reward = 0;\n        uint256 wrappedTokenReward = 0;\n\n        uint256 _percent = CalculateRewardLib._getPercentageReward(\n            _staker[_stakeIndex].rank,\n            _prizeRewardRates\n        );\n\n        reward = reward.add(\n                        _lps.prizeAmount.mulBP(_percent)\n                    );\n\n        wrappedTokenReward = wrappedTokenReward.add(\n                        maturingWrappedTokenPrizeAmount\n                            .mulBP(_percent)\n                    );            \n\n        if (_lps.collaborativeReward > 0) {\n            reward = reward.addBP(_lps.collaborativeReward);\n            wrappedTokenReward = wrappedTokenReward.addBP(_lps.collaborativeReward);\n        }\n\n        return (reward, wrappedTokenReward);\n    }\n}\n\n"
    },
    "contracts/libraries/ClaimRewardLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./CalculateRewardLib.sol\";\nimport \"../libraries/BasisPoints.sol\";\nimport \"../Staking/StakingPoolStorageStructure.sol\";\n\nlibrary ClaimRewardLib {\n\n    using CalculateRewardLib for *;\n    using BasisPoints for uint256; \n    using SafeMath for uint256;\n\n    uint256 public constant foo = 0;\n\n    function withdrawStakingReturn(\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker,\n        StakingPoolStorageStructure.LibParams storage _lps\n    )\n        public \n    {\n        \n        if (_staker.length == 0) return;\n\n        for (uint256 i = 0; i < _staker.length; i++) {\n            uint256 rewardPerStake = CalculateRewardLib._getStakingRewardPerStake(\n                _staker, \n                i, \n                _lps);\n\n            _staker[i].lastWithdrawalTime = block.timestamp;\n            _staker[i].amountWithdrawn = _staker[i].amountWithdrawn.add(\n                rewardPerStake\n            );\n        }\n    }\n\n    function withdrawPrize(\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker\n    ) \n        public\n    {\n        if (_staker.length == 0) return;\n\n        for (uint256 i = 0; i < _staker.length; i++) {\n            _staker[i].prizeRewardWithdrawn = true;\n        }\n    }\n\n    function withdrawStakedBalance(\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker\n    )\n        public \n    {\n        \n        if (_staker.length == 0) return;\n\n        for (uint256 i = 0; i < _staker.length; i++) {\n            _staker[i].didUnstake = true;\n        }\n    }\n\n    function getStakingReturn(\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker,\n        StakingPoolStorageStructure.LibParams storage _lps  \n    ) \n        public \n        view \n        returns (uint256) \n    {\n        if (_staker.length == 0) return 0;\n\n        uint256 reward = 0;\n        for (uint256 i = 0; i < _staker.length; i++) {\n            uint256 rewardPerStake = CalculateRewardLib._getStakingRewardPerStake(\n                _staker,\n                i, \n                _lps\n            );\n\n            reward = reward.add(rewardPerStake);\n        }\n\n        return reward;\n    }\n\n    function getPrize(\n        StakingPoolStorageStructure.StakeWithPrediction[] storage _staker, \n        StakingPoolStorageStructure.LibParams storage _lps,\n        StakingPoolStorageStructure.PrizeRewardRate[] storage _prizeRewardRates\n    )\n        public\n        view\n        returns (uint256, uint256)\n    {\n        if (!_lps.isMatured) return (0, 0);\n\n        if (_staker.length == 0) return (0, 0);\n\n        uint256 maturingWrappedTokenPrizeAmount =\n            (_lps.usdPrizeAmount.mul(10**_lps.oracleDecimals)).div(_lps.maturingPrice);\n\n        uint256 reward = 0;\n        uint256 wrappedTokenReward = 0;\n\n        for (uint256 i = 0; i < _staker.length; i++) {\n            if (!_staker[i].prizeRewardWithdrawn) {\n\n                uint256 _percent = CalculateRewardLib._getPercentageReward(\n                    _staker[i].rank,\n                    _prizeRewardRates\n                );\n\n                reward = reward.add(\n                            _lps.prizeAmount.mulBP(_percent)\n                        );\n\n                wrappedTokenReward = wrappedTokenReward.add(\n                            maturingWrappedTokenPrizeAmount\n                                .mulBP(_percent)\n                        );        \n            }\n        }\n\n        if (_lps.collaborativeReward > 0) {\n            reward = reward.addBP(_lps.collaborativeReward);\n            wrappedTokenReward = wrappedTokenReward.addBP(_lps.collaborativeReward);\n        }\n\n        return (reward, wrappedTokenReward);\n    }\n\n}\n\n"
    },
    "contracts/libraries/PriceConsumer.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nlibrary PriceConsumer {\n    /**\n     * @param oracle The chainlink node oracle address to send requests\n     * @notice Returns decimals for oracle contract\n     */\n    function getDecimals(address oracle) internal view returns (uint8) {\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(oracle);\n        uint8 decimals = priceFeed.decimals();\n        return decimals;\n    }\n\n    /**\n     * @notice Returns the latest price from oracle contract\n     */\n    function getLatestPrice(address oracle) internal view returns (uint256) {\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(oracle);\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n\n        return price >= 0 ? uint256(price) : 0;\n    }\n}\n"
    },
    "contracts/interfaces/ITotemToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface ITotemToken {\n    \n    function setLocker(address _locker) external;\n\n    function setDistributionTeamsAddresses(\n        address _CommunityDevelopmentAddr,\n        address _StakingRewardsAddr,\n        address _LiquidityPoolAddr,\n        address _PublicSaleAddr,\n        address _AdvisorsAddr,\n        address _SeedInvestmentAddr,\n        address _PrivateSaleAddr,\n        address _TeamAllocationAddr,\n        address _StrategicRoundAddr\n    ) external;\n\n    function distributeTokens() external;\n\n    function setTaxRate(uint256 newTaxRate) external;\n\n    function setTaxExemptStatus(address account, bool status) external;\n\n    function setTaxationWallet(address newTaxationWallet) external;\n\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function taxRate() external returns (uint256);\n\n    function taxationWallet() external returns (address);\n\n    function taxExempt(address _msgSender) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IPancakeRouter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface IPancakeRouter01 {\n    function factory() external view returns (address);\n\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n\ninterface IPancakeRouter02 is IPancakeRouter01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/Staking/StakingPoolImplementation.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./StakingPoolStorageStructure.sol\";\n\ncontract StakingPoolImplementation is StakingPoolStorageStructure {\n    using BasisPoints for uint256;\n    using SafeMath for uint256;\n    using CalculateRewardLib for *;\n    using IndexedClaimRewardLib for *;\n    using ClaimRewardLib for *;\n    using PriceConsumer for *;\n\n    modifier onlyPoolCreator() {\n        require(\n            _msgSender() == poolCreator,\n            \"0300 caller is not a pool creator\"\n        );\n        _;\n    }\n\n    event Stake(\n        address indexed user,\n        uint256 amount,\n        uint256 pricePrediction,\n        uint256 indexOfStake\n    );\n\n    // TODO: add the index of stakes for BatchStake event too\n    event BatchStake(\n        address indexed user,\n        uint256[] stakeAmounts,\n        uint256[] predictions,\n        uint256 indexOfFirstStake,\n        uint256 indexOfLastStake\n    );\n\n    event WithdrawStakingReturn(address indexed user, uint256 stakingReturn);\n    event WithdrawTotemPrize(address indexed user, uint256 totemPrize);\n    event WithdrawWrappedTokenPrize(\n        address indexed user,\n        uint256 wrappedTokenPrize\n    );\n    event Unstake(address indexed user, uint256 amount);\n\n    event PoolActivated();\n    event PoolDeactivated();\n    event PoolLocked();\n    event PoolSorted();\n    event PoolMatured();\n    event PoolDeleted();\n\n    function setActivationStatus(bool _activationStatus)\n        external\n        onlyPoolCreator\n    {\n        require(\n            isActive != _activationStatus,\n            \"Not changing the activation status\"\n        );\n        isActive = _activationStatus;\n\n        if (isActive) emit PoolActivated();\n        else emit PoolDeactivated();\n    }\n\n    function stake(uint256 _amount, uint256 _pricePrediction) external {\n        require(\n            isActive && block.timestamp > launchDate,\n            \"0313 pool is not active\"\n        );\n        require(\n            block.timestamp < (launchDate + lockTime),\n            \"0316 Can not stake after lock date\"\n        );\n        require(!isLocked, \"0310 Pool is locked\");\n        require(\n            _amount >= minimumStakeAmount,\n            \"0311 Amount can't be less than the minimum\"\n        );\n\n        // uint256 limitRange = sizeAllocation.mul(sizeLimitRangeRate).div(100);\n        uint256 limitRange = minimumStakeAmount;\n        uint256 taxRate = totemToken.taxRate();\n        uint256 tax = totemToken.taxExempt(_msgSender())\n            ? 0\n            : _amount.mulBP(taxRate);\n\n        require(\n            totalStaked.add(_amount).sub(tax) <= sizeAllocation.add(limitRange),\n            \"0312 Can't stake above size allocation\"\n        );\n\n        uint256 stakeTaxAmount;\n\n        (stakeTaxAmount, _amount) = getStakingTax(_amount, taxRate);\n\n        totemToken.transferFrom(\n            _msgSender(),\n            address(this),\n            (_amount + stakeTaxAmount)\n        );\n\n        /// @dev This is to remove token tax (not staking tax) from the amount\n        _amount = _amount.sub(tax);\n\n        if (stakeTaxAmount > 0)\n            totemToken.transfer(totemToken.taxationWallet(), stakeTaxAmount);\n\n        uint256 indexOfStake = predictions[_msgSender()].length;\n\n        _stake(_msgSender(), _amount, _pricePrediction);\n\n        totalStaked = totalStaked.add(_amount);\n\n        if (totalStaked >= sizeAllocation) {\n            _lockPool();\n        }\n\n        emit Stake(_msgSender(), _amount, _pricePrediction, indexOfStake);\n    }\n\n    function batchStake(\n        uint256[] calldata _stakingAmounts,\n        uint256[] calldata _predictions\n    ) external {\n        require(\n            isActive && block.timestamp > launchDate,\n            \"0313 pool is not active\"\n        );\n        require(\n            block.timestamp < (launchDate + lockTime),\n            \"0316 Can not stake after lock date\"\n        );\n        require(!isLocked, \"0310 Pool is locked\");\n        require(\n            _stakingAmounts.length == _predictions.length,\n            \"0315 stakingAmount and predictions length mismatch\"\n        );\n\n        uint256 totalStakingAmount = 0;\n\n        for (uint256 i; i < _stakingAmounts.length; i++) {\n            require(\n                _stakingAmounts[i] >= minimumStakeAmount,\n                \"0311 Amount can't be less than the minimum\"\n            );\n            totalStakingAmount = totalStakingAmount.add(_stakingAmounts[i]);\n        }\n\n        // uint256 limitRange = sizeAllocation.mul(sizeLimitRangeRate).div(100);\n        uint256 limitRange = minimumStakeAmount;\n        uint256 taxRate = totemToken.taxRate();\n        uint256 tax = totemToken.taxExempt(_msgSender())\n            ? 0\n            : totalStakingAmount.mulBP(taxRate);\n\n        require(\n            totalStaked.add(totalStakingAmount).sub(tax) <=\n                sizeAllocation.add(limitRange),\n            \"0312 Can't stake above size allocation\"\n        );\n\n        uint256 stakeTaxAmount;\n\n        (stakeTaxAmount, totalStakingAmount) = getStakingTax(\n            totalStakingAmount,\n            taxRate\n        );\n\n        totemToken.transferFrom(\n            _msgSender(),\n            address(this),\n            (totalStakingAmount + stakeTaxAmount)\n        );\n\n        /// @dev This is to remove token tax (not staking tax) from the amount\n        totalStakingAmount = totalStakingAmount.sub(tax);\n\n        if (stakeTaxAmount > 0)\n            totemToken.transfer(totemToken.taxationWallet(), stakeTaxAmount);\n\n        uint256 indexOfFirstStake = predictions[_msgSender()].length;\n\n        for (uint256 i; i < _stakingAmounts.length; i++) {\n            uint256 stakingAmount = _stakingAmounts[i];\n\n            tax = totemToken.taxExempt(_msgSender())\n                ? 0\n                : stakingAmount.mulBP(taxRate);\n\n            (stakeTaxAmount, stakingAmount) = getStakingTax(\n                stakingAmount,\n                taxRate\n            );\n\n            /// @dev This is to remove token tax (not staking tax) from the amount\n            stakingAmount = stakingAmount.sub(tax);\n\n            _stake(_msgSender(), stakingAmount, _predictions[i]);\n\n            totalStaked = totalStaked.add(stakingAmount);\n        }\n\n        uint256 indexOfLastStake = predictions[_msgSender()].length - 1;\n\n        if (totalStaked >= sizeAllocation) {\n            _lockPool();\n        }\n\n        emit BatchStake(\n            _msgSender(),\n            _stakingAmounts,\n            _predictions,\n            indexOfFirstStake,\n            indexOfLastStake\n        );\n    }\n\n    function _stake(\n        address _staker,\n        uint256 _amount,\n        uint256 _pricePrediction\n    ) internal {\n        stakers.push(\n            Staker({stakerAddress: _staker, index: predictions[_staker].length})\n        );\n\n        predictions[_staker].push(\n            StakeWithPrediction({\n                stakedBalance: _amount,\n                stakedTime: block.timestamp,\n                amountWithdrawn: 0,\n                lastWithdrawalTime: block.timestamp,\n                pricePrediction: _pricePrediction,\n                difference: type(uint256).max,\n                rank: type(uint256).max,\n                prizeRewardWithdrawn: false,\n                didUnstake: false\n            })\n        );\n\n        _getAveragePricePrediction(_pricePrediction, _amount);\n    }\n\n    function getStakingTax(uint256 amount, uint256 tokenTaxRate)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        uint256 newStakeTaxRate = stakeTaxRate > tokenTaxRate\n            ? stakeTaxRate.sub(tokenTaxRate)\n            : 0;\n        if (newStakeTaxRate == 0) {\n            return (0, amount);\n        }\n        return (\n            amount.mulBP(newStakeTaxRate),\n            amount.sub(amount.mulBP(newStakeTaxRate))\n        );\n    }\n\n    function claimReward() external {\n        uint256 stakingReturn = ClaimRewardLib.getStakingReturn(\n            predictions[_msgSender()],\n            lps\n        );\n\n        (uint256 totemPrize, uint256 wrappedTokenPrize) = ClaimRewardLib\n            .getPrize(predictions[_msgSender()], lps, prizeRewardRates);\n\n        uint256 withdrawableTotemReward = totemPrize + stakingReturn;\n\n        if (isMatured) {\n            if (usdPrizeAmount > 0) {\n                if (wrappedTokenPrize > 0) {\n                    /// @dev Not the actual withdraw, only updating the array in the mapping\n                    ClaimRewardLib.withdrawPrize(predictions[_msgSender()]);\n\n                    require(\n                        wrappedToken.transfer(_msgSender(), wrappedTokenPrize),\n                        \"0320\"\n                    );\n\n                    emit WithdrawWrappedTokenPrize(\n                        _msgSender(),\n                        wrappedTokenPrize\n                    );\n                }\n            }\n\n            if (totemPrize > 0) {\n                ClaimRewardLib.withdrawPrize(predictions[_msgSender()]);\n            }\n\n            uint256 stakedBalance = CalculateRewardLib.getTotalStakedBalance(\n                predictions[_msgSender()]\n            );\n\n            if (stakedBalance > 0) {\n                ClaimRewardLib.withdrawStakedBalance(predictions[_msgSender()]);\n\n                totemToken.transfer(_msgSender(), stakedBalance);\n\n                emit Unstake(_msgSender(), stakedBalance);\n            }\n        }\n\n        /// @dev before maturity, totemPrize is always zero\n        if (withdrawableTotemReward > 0) {\n            /// @dev Send the token reward only when rewardManager has the enough funds\n            require(\n                totemToken.balanceOf(address(rewardManager)) >=\n                    withdrawableTotemReward,\n                \"Not enough balance in reward manager\"\n            );\n\n            ClaimRewardLib.withdrawStakingReturn(\n                predictions[_msgSender()],\n                lps\n            );\n\n            rewardManager.rewardUser(_msgSender(), withdrawableTotemReward);\n\n            emit WithdrawStakingReturn(_msgSender(), stakingReturn);\n            emit WithdrawTotemPrize(_msgSender(), totemPrize);\n        }\n    }\n\n    function indexedClaimReward(uint256 stakeIndex) external {\n        require(\n            predictions[_msgSender()].length >= stakeIndex,\n            \"Index does not exist\"\n        );\n        require(\n            predictions[_msgSender()].length != 0,\n            \"User does not have any stakes\"\n        );\n\n        uint256 stakingReturn = IndexedClaimRewardLib.getIndexedStakingReturn(\n            predictions[_msgSender()],\n            stakeIndex,\n            lps\n        );\n\n        (uint256 totemPrize, uint256 wrappedTokenPrize) = IndexedClaimRewardLib\n            .getIndexedPrize(\n                predictions[_msgSender()],\n                stakeIndex,\n                lps,\n                prizeRewardRates\n            );\n\n        uint256 withdrawableTotemReward = totemPrize + stakingReturn;\n\n        if (isMatured) {\n            if (usdPrizeAmount > 0) {\n                if (wrappedTokenPrize > 0) {\n                    IndexedClaimRewardLib.withdrawIndexedPrize(\n                        predictions[_msgSender()],\n                        stakeIndex\n                    );\n\n                    require(\n                        wrappedToken.transfer(_msgSender(), wrappedTokenPrize),\n                        \"0330\"\n                    );\n\n                    emit WithdrawWrappedTokenPrize(\n                        _msgSender(),\n                        wrappedTokenPrize\n                    );\n                }\n            }\n\n            if (totemPrize > 0) {\n                IndexedClaimRewardLib.withdrawIndexedPrize(\n                    predictions[_msgSender()],\n                    stakeIndex\n                );\n            }\n\n            uint256 stakedBalance = IndexedClaimRewardLib\n                .getIndexedStakedBalance(predictions[_msgSender()], stakeIndex);\n\n            if (stakedBalance > 0) {\n                IndexedClaimRewardLib.withdrawIndexedStakedBalance(\n                    predictions[_msgSender()],\n                    stakeIndex\n                );\n\n                totemToken.transfer(_msgSender(), stakedBalance);\n\n                emit Unstake(_msgSender(), stakedBalance);\n            }\n        }\n\n        /// @dev before maturity, totemPrize is always zero\n        if (withdrawableTotemReward > 0) {\n            /// @dev Send the token reward only when rewardManager has the enough funds\n            require(\n                totemToken.balanceOf(address(rewardManager)) >=\n                    withdrawableTotemReward,\n                \"Not enough balance in reward manager\"\n            );\n\n            IndexedClaimRewardLib.withdrawIndexedStakingReturn(\n                predictions[_msgSender()],\n                stakeIndex,\n                lps\n            );\n\n            rewardManager.rewardUser(_msgSender(), withdrawableTotemReward);\n\n            emit WithdrawStakingReturn(_msgSender(), stakingReturn);\n            emit WithdrawTotemPrize(_msgSender(), totemPrize);\n        }\n    }\n\n    function purchaseWrappedToken(uint256 usdAmount, uint256 deadline)\n        external\n        onlyPoolCreator\n    {\n        //TODO: require usdAmount to be more than usdPrizeAmount, to have enough rewards\n        require(usdPrizeAmount > 0, \"0340 The pool is only TOTM rewarder\");\n\n        require(usdAmount > 0, \"0341 Amount can't be zero\");\n\n        require(deadline >= block.timestamp, \"0342 Deadline is low\");\n\n        address swapRouterAddress = getSwapRouter();\n        approveTokens(swapRouterAddress, usdAmount);\n\n        uint256 wrappedTokenAmount = getEstimatedWrappedTokenForUSD(usdAmount);\n\n        uint256 wrappedTokenAmountWithSlippage = wrappedTokenAmount.sub(\n            wrappedTokenAmount.mulBP(300)\n        );\n\n        transferTokensThroughSwap(\n            address(this),\n            usdAmount,\n            wrappedTokenAmountWithSlippage,\n            deadline\n        );\n    }\n\n    function getWrappedTokenBalance() public view returns (uint256) {\n        return wrappedToken.balanceOf(address(this));\n    }\n\n    function lockPool() public virtual onlyPoolCreator {\n        _lockPool();\n    }\n\n    function _lockPool() internal {\n        isLocked = true;\n\n        emit PoolLocked();\n    }\n\n    /**\n     * @param _predictionPrice is ignored if oracle is not zero address.When there is no oracle,\n             _predictionPrice is the maturingPrice and is set manually by the pool creator\n     * @param _prizePrice is ignored if oracle is not zero address.When there is no oracle,\n             _predictionPrice is the maturingPrice and is set manually by the pool creator\n    */\n    function updateMaturingPrice(\n        uint256 _predictionPrice,\n        bool _samePredictionPrizeToken,\n        uint256 _prizePrice,\n        address _oracleContract,\n        uint256 _oracleDecimals\n    ) external onlyPoolCreator {\n        require(\n            block.timestamp >= launchDate + lockTime + maturityTime,\n            \"0350 Can't set maturing price before the maturity time\"\n        );\n\n        if (_samePredictionPrizeToken) {\n            if (oracleContract != address(0)) {\n                maturingPrice = PriceConsumer.getLatestPrice(oracleContract);\n                lps.maturingPrice = maturingPrice;\n                lps.oracleDecimals = oracleDecimals;\n            } else {\n                maturingPrice = _predictionPrice;\n                lps.maturingPrice = _predictionPrice;\n                lps.oracleDecimals = oracleDecimals;\n            }\n        } else {\n            if (oracleContract != address(0)) {\n                if (_oracleContract != address(0)) {\n                    maturingPrice = PriceConsumer.getLatestPrice(\n                        oracleContract\n                    );\n                    lps.maturingPrice = PriceConsumer.getLatestPrice(\n                        _oracleContract\n                    );\n                    lps.oracleDecimals = PriceConsumer.getDecimals(\n                        _oracleContract\n                    );\n                } else {\n                    maturingPrice = PriceConsumer.getLatestPrice(\n                        oracleContract\n                    );\n                    lps.maturingPrice = _prizePrice;\n                    lps.oracleDecimals = _oracleDecimals;\n                }\n            } else {\n                if (_oracleContract != address(0)) {\n                    maturingPrice = _predictionPrice;\n                    lps.maturingPrice = PriceConsumer.getLatestPrice(\n                        _oracleContract\n                    );\n                    lps.oracleDecimals = PriceConsumer.getDecimals(\n                        _oracleContract\n                    );\n                } else {\n                    maturingPrice = _predictionPrice;\n                    lps.maturingPrice = _prizePrice;\n                    lps.oracleDecimals = _oracleDecimals;\n                }\n            }\n        }\n    }\n\n    function getLPS() public view returns (uint256, uint256) {\n        return (lps.maturingPrice, lps.oracleDecimals);\n    }\n\n    function getPrizeTokenDecimals(address _oracleContract)\n        public\n        view\n        returns (uint256)\n    {\n        return PriceConsumer.getDecimals(_oracleContract);\n    }\n\n    /**\n     * @notice Sets oracle to zero in case it was given incorrectly by the owner,\n     *         or it is not available\n     */\n    function setOracleToZero() external onlyPoolCreator {\n        oracleContract = address(0);\n    }\n\n    /**\n     * @notice Sets oracle to zero in case it was given incorrectly by the owner,\n     *         or it is not available\n     */\n\n    function setSortedStakers(\n        address[25] calldata addrArray,\n        uint256[25] calldata indexArray\n    ) external onlyPoolCreator {\n        require(\n            block.timestamp >= launchDate + lockTime + maturityTime,\n            \"0390 Can't set sorted stakers before the maturity time\"\n        );\n\n        if (sortedStakers.length != 0) {\n            delete sortedStakers;\n        }\n\n        uint256 i;\n        for (i = 0; i < addrArray.length; i++) {\n            /// @dev The first 0 address means the other addresses are also 0 so they won't be checked\n            if (addrArray[i] == address(0)) break;\n\n            sortedStakers.push(\n                Staker({stakerAddress: addrArray[i], index: indexArray[i]})\n            );\n\n            predictions[addrArray[i]][indexArray[i]].rank = i + 1;\n        }\n\n        require(\n            prizeRewardRates[prizeRewardRates.length - 1].rank >= i,\n            \"number of sorted stakers must be less than or equal to the last rank\"\n        );\n\n        emit PoolSorted();\n    }\n\n    function endPool() external onlyPoolCreator {\n        require(\n            block.timestamp >= launchDate + lockTime + maturityTime,\n            \"0360 Can't end pool before the maturity time\"\n        );\n\n        //TODO: check to see if there is enough USD to buy the wrapped token with, the mimimum USD\n        // must be usdPrizeAmount, if there is not, do not allow endPool\n        if (usdPrizeAmount > 0) {\n            require(\n                getWrappedTokenBalance() != 0,\n                \"0361 WrappedToken Rewards not available\"\n            );\n        }\n\n        if (stakers.length > 0) {\n            require(sortedStakers.length != 0, \"0362 first should sort\");\n        }\n\n        /**\n         *  @dev potentialCollabReward allows the admin to set the collaborateive reward\n         *  @notice the collaborative reward is only given to the pools which the average price\n         *          predicted has the accuracy of 25$\n         */\n        if (potentialCollabReward > 0) {\n            if (\n                getDifference(averagePricePrediction, collaborativeRange) == 0\n            ) {\n                collaborativeReward = potentialCollabReward;\n                lps.collaborativeReward = collaborativeReward;\n            }\n        }\n\n        isLocked = true;\n        isMatured = true;\n        lps.isMatured = isMatured;\n\n        emit PoolMatured();\n    }\n\n    function getDifference(uint256 prediction, uint256 _range)\n        public\n        view\n        returns (uint256)\n    {\n        if (_range > prediction) return 0;\n\n        if (prediction > maturingPrice) {\n            if (prediction.sub(_range) <= maturingPrice) return 0;\n            else return prediction.sub(_range).sub(maturingPrice);\n        } else {\n            if (prediction.add(_range) >= maturingPrice) return 0;\n            else return maturingPrice.sub(prediction.add(_range));\n        }\n    }\n\n    /**\n     * @notice Gets the avgerage price prediction for calculating collaborative reward\n     */\n    function _getAveragePricePrediction(uint256 _prediction, uint256 _amount)\n        internal\n    {\n        uint256 predictionsCount = stakers.length - 1;\n\n        if (predictionsCount == 0) averagePricePrediction = _prediction;\n\n        averagePricePrediction = averagePricePrediction\n            .mul(totalStaked)\n            .add(_prediction.mul(_amount))\n            .div(totalStaked.add(_amount));\n    }\n\n    function deletePool() external onlyPoolCreator {\n        isDeleted = true;\n        emit PoolDeleted();\n    }\n\n    function getStakers()\n        public\n        view\n        returns (address[] memory, uint256[] memory)\n    {\n        address[] memory addrs = new address[](stakers.length);\n        uint256[] memory indexes = new uint256[](stakers.length);\n\n        for (uint256 i = 0; i < stakers.length; i++) {\n            addrs[i] = stakers[i].stakerAddress;\n            indexes[i] = stakers[i].index;\n        }\n\n        return (addrs, indexes);\n    }\n\n    function getStakingReward(address _staker) public view returns (uint256) {\n        uint256 reward = ClaimRewardLib.getStakingReturn(\n            predictions[_staker],\n            lps\n        );\n\n        return reward;\n    }\n\n    function getIndexedStakingReward(address _staker, uint256 _stakeIndex)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 reward = IndexedClaimRewardLib.getIndexedStakingReturn(\n            predictions[_staker],\n            _stakeIndex,\n            lps\n        );\n\n        return reward;\n    }\n\n    function getPrize(address _staker) public view returns (uint256, uint256) {\n        (uint256 reward, uint256 wrappedTokenReward) = ClaimRewardLib.getPrize(\n            predictions[_staker],\n            lps,\n            prizeRewardRates\n        );\n\n        return (reward, wrappedTokenReward);\n    }\n\n    function getIndexedPrize(address _staker, uint256 _stakeIndex)\n        public\n        view\n        returns (uint256, uint256)\n    {\n        (uint256 reward, uint256 wrappedTokenReward) = IndexedClaimRewardLib\n            .getIndexedPrize(\n                predictions[_staker],\n                _stakeIndex,\n                lps,\n                prizeRewardRates\n            );\n\n        return (reward, wrappedTokenReward);\n    }\n\n    /**  \n     * @notice hasUnStaked return true if the user staked in the pool and then \n            has unStaked it (claimed)\n    */\n    function hasUnStaked(address staker, uint256 stakeIndex)\n        external\n        view\n        returns (bool)\n    {\n        StakeWithPrediction[] memory userStakes = predictions[staker];\n\n        require(\n            userStakes.length > 0,\n            \"0380 this address didn't stake in this pool\"\n        );\n\n        require(stakeIndex < userStakes.length, \"0381 this index exceeds\");\n\n        if (userStakes[stakeIndex].didUnstake) {\n            return true;\n        }\n        return false;\n    }\n\n    function withdrawStuckTokens(\n        address _stuckToken,\n        uint256 amount,\n        address receiver\n    ) external onlyPoolCreator {\n        require(\n            _stuckToken != address(totemToken),\n            \"0370 totems can not be transfered\"\n        );\n        IERC20 stuckToken = IERC20(_stuckToken);\n        stuckToken.transfer(receiver, amount);\n    }\n\n    function declareEmergency() external onlyPoolCreator {\n        isActive = false;\n        isAnEmergency = true;\n\n        _lockPool();\n    }\n\n    function emergentWithdraw() external {\n        require(isAnEmergency, \"it's not an emergency\");\n\n        uint256 stakedBalance = CalculateRewardLib.getTotalStakedBalance(\n            predictions[_msgSender()]\n        );\n        if (stakedBalance > 0) {\n            ClaimRewardLib.withdrawStakedBalance(predictions[_msgSender()]);\n\n            totemToken.transfer(_msgSender(), stakedBalance);\n\n            emit Unstake(_msgSender(), stakedBalance);\n        }\n    }\n}\n"
    },
    "contracts/Test/StakingPoolImplementationForTest.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\n\nimport \"../Staking/StakingPoolImplementation.sol\";\n\ncontract StakingPoolImplementationForTest is StakingPoolImplementation {\n    event PoolUnLocked();\n\n    \n    // TODO: we should decide which functions we may want to override so that we can add \n    // \"virtual\" to them\n    /**\n     * @dev If pool is locked unwantedly, we can reverse it like this\n     */\n    function lockPool() public onlyPoolCreator override {\n        _unlockPool();\n    }\n\n    function _unlockPool() internal {\n        isLocked = false;\n\n        emit PoolUnLocked();\n    }\n}"
    },
    "contracts/Test/TotemVesting/PrivateSaleVesting.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./TotemVesting.sol\";\nimport \"../../libraries/BasisPoints.sol\";\n\ncontract PrivateSaleVesting is TotemVesting {\n    using BasisPoints for uint256;\n    using SafeMath for uint256;\n\n    uint256 public constant TOTAL_AMOUNT = 2000000 * (10**18);\n    uint256 public constant WITHDRAW_INTERVAL = 30 days;\n    uint256 public constant RELEASE_PERIODS = 5;\n    uint256 public constant LOCK_PERIODS = 0;\n\n    uint256 public constant INITIAL_UNLOCK = 2250;\n\n    constructor(TotemToken _totemToken)\n        TotemVesting(\n            _totemToken,\n            TOTAL_AMOUNT,\n            WITHDRAW_INTERVAL,\n            RELEASE_PERIODS,\n            LOCK_PERIODS\n        )\n    {}\n\n    // Returns the amount of tokens you can withdraw\n    function vested(address beneficiary)\n        public\n        view\n        override\n        returns (uint256 _amountVested)\n    {\n        VestingSchedule memory _vestingSchedule = recipients[beneficiary];\n        if (\n            !isStartTimeSet ||\n            (_vestingSchedule.totalAmount == 0) ||\n            (lockPeriods == 0 && releasePeriods == 0) ||\n            (block.timestamp < startTime)\n        ) {\n            return 0;\n        }\n\n        uint256 endLock = withdrawInterval.mul(lockPeriods);\n        if (block.timestamp < startTime.add(endLock)) {\n            return 0;\n        }\n\n        uint256 _end = withdrawInterval.mul(lockPeriods.add(releasePeriods));\n        if (block.timestamp >= startTime.add(_end)) {\n            return _vestingSchedule.totalAmount;\n        }\n\n        uint256 period =\n            block.timestamp.sub(startTime).div(withdrawInterval) + 1;\n        if (period <= lockPeriods) {\n            return 0;\n        }\n        if (period >= lockPeriods.add(releasePeriods)) {\n            return _vestingSchedule.totalAmount;\n        }\n\n        uint256 initialUnlockAmount =\n            _vestingSchedule.totalAmount.mulBP(INITIAL_UNLOCK);\n\n        if (period.sub(lockPeriods) == 1) {\n            return initialUnlockAmount;\n        }\n\n        uint256 lockAmount =\n            _vestingSchedule.totalAmount.sub(initialUnlockAmount).div(\n                releasePeriods - 1\n            );\n\n        uint256 vestedAmount =\n            period.sub(lockPeriods + 1).mul(lockAmount).add(\n                initialUnlockAmount\n            );\n        return vestedAmount;\n    }\n}\n"
    },
    "contracts/Test/TotemVesting/TotemVesting.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"../TotemToken.sol\";\n\ncontract TotemVesting is Context, Ownable {\n    using SafeMath for uint256;\n\n    struct VestingSchedule {\n        uint256 totalAmount; // Total amount of tokens to be vested.\n        uint256 amountWithdrawn; // The amount that has been withdrawn.\n    }\n\n    mapping(address => VestingSchedule) public recipients;\n\n    uint256 public startTime;\n    bool public isStartTimeSet;\n    uint256 public withdrawInterval; // Amount of time in seconds between withdrawal periods.\n    uint256 public releasePeriods; // Number of periods from start release until done.\n    uint256 public lockPeriods; // Number of periods before start release.\n\n    uint256 public totalAmount; // Total amount of tokens to be vested.\n    uint256 public unallocatedAmount; // The amount of tokens that are not allocated yet.\n\n    TotemToken public totemToken;\n\n    event VestingScheduleRegistered(\n        address registeredAddress,\n        uint256 totalAmount\n    );\n    event Withdraw(address registeredAddress, uint256 amountWithdrawn);\n    event StartTimeSet(uint256 startTime);\n\n    constructor(\n        TotemToken _totemToken,\n        uint256 _totalAmount,\n        uint256 _withdrawInterval,\n        uint256 _releasePeriods,\n        uint256 _lockPeriods\n    ) {\n        require(_totalAmount > 0);\n        require(_withdrawInterval > 0);\n        require(_releasePeriods > 0);\n\n        totemToken = _totemToken;\n\n        totalAmount = _totalAmount;\n        unallocatedAmount = _totalAmount;\n        withdrawInterval = _withdrawInterval;\n        releasePeriods = _releasePeriods;\n        lockPeriods = _lockPeriods;\n\n        isStartTimeSet = false;\n    }\n\n    function addRecipient(address _newRecipient, uint256 _totalAmount)\n        public\n        onlyOwner\n    {\n        // Only allow to add recipient before the counting starts\n        require(!isStartTimeSet || startTime > block.timestamp);\n\n        require(_newRecipient != address(0));\n\n        // If the vesting amount for the recipient was already set, remove it and update with the new amount\n        if (recipients[_newRecipient].totalAmount > 0) {\n            unallocatedAmount = unallocatedAmount.add(\n                recipients[_newRecipient].totalAmount\n            );\n        }\n        require(_totalAmount > 0 && _totalAmount <= unallocatedAmount);\n\n        recipients[_newRecipient] = VestingSchedule({\n            totalAmount: _totalAmount,\n            amountWithdrawn: 0\n        });\n        unallocatedAmount = unallocatedAmount.sub(_totalAmount);\n\n        emit VestingScheduleRegistered(_newRecipient, _totalAmount);\n    }\n\n    function setStartTime(uint256 _newStartTime) public onlyOwner {\n        // Only allow to change start time before the counting starts\n        require(!isStartTimeSet || startTime > block.timestamp);\n        require(_newStartTime > block.timestamp);\n\n        startTime = _newStartTime;\n        isStartTimeSet = true;\n\n        emit StartTimeSet(_newStartTime);\n    }\n\n    // Returns the amount of tokens you can withdraw\n    function vested(address beneficiary)\n        public\n        view\n        virtual\n        returns (uint256 _amountVested)\n    {\n        VestingSchedule memory _vestingSchedule = recipients[beneficiary];\n        if (\n            !isStartTimeSet ||\n            (_vestingSchedule.totalAmount == 0) ||\n            (lockPeriods == 0 && releasePeriods == 0) ||\n            (block.timestamp < startTime)\n        ) {\n            return 0;\n        }\n\n        uint256 endLock = withdrawInterval.mul(lockPeriods);\n        if (block.timestamp < startTime.add(endLock)) {\n            return 0;\n        }\n\n        uint256 _end = withdrawInterval.mul(lockPeriods.add(releasePeriods));\n        if (block.timestamp >= startTime.add(_end)) {\n            return _vestingSchedule.totalAmount;\n        }\n\n        uint256 period =\n            block.timestamp.sub(startTime).div(withdrawInterval) + 1;\n        if (period <= lockPeriods) {\n            return 0;\n        }\n        if (period >= lockPeriods.add(releasePeriods)) {\n            return _vestingSchedule.totalAmount;\n        }\n\n        uint256 lockAmount = _vestingSchedule.totalAmount.div(releasePeriods);\n\n        uint256 vestedAmount = period.sub(lockPeriods).mul(lockAmount);\n        return vestedAmount;\n    }\n\n    function withdrawable(address beneficiary)\n        public\n        view\n        returns (uint256 amount)\n    {\n        return vested(beneficiary).sub(recipients[beneficiary].amountWithdrawn);\n    }\n\n    function withdraw() public {\n        VestingSchedule storage vestingSchedule = recipients[_msgSender()];\n        if (vestingSchedule.totalAmount == 0) return;\n\n        uint256 _vested = vested(_msgSender());\n        uint256 _withdrawable = withdrawable(_msgSender());\n        vestingSchedule.amountWithdrawn = _vested;\n\n        if (_withdrawable > 0) {\n            require(totemToken.transfer(_msgSender(), _withdrawable));\n            emit Withdraw(_msgSender(), _withdrawable);\n        }\n    }\n}\n"
    },
    "contracts/Test/TotemToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"../interfaces/ILocker.sol\";\nimport \"../libraries/BasisPoints.sol\";\n\ncontract TotemToken is ILockerUser, Context, ERC20, Ownable {\n    using BasisPoints for uint256;\n    using SafeMath for uint256;\n\n    string public constant NAME = \"Totem Token\";\n    string public constant SYMBOL = \"TOTM\";\n    uint8 public constant DECIMALS = 18;\n    uint256 public constant INITIAL_SUPPLY = 10000000 * (10**uint256(DECIMALS));\n\n    address public CommunityDevelopmentAddr;\n    address public StakingRewardsAddr;\n    address public LiquidityPoolAddr;\n    address public PublicSaleAddr;\n    address public AdvisorsAddr;\n    address public SeedInvestmentAddr;\n    address public PrivateSaleAddr;\n    address public TeamAllocationAddr;\n    address public StrategicRoundAddr;\n\n    uint256 public constant COMMUNITY_DEVELOPMENT =\n        1000000 * (10**uint256(DECIMALS)); // 10% for Community development\n    uint256 public constant STAKING_REWARDS = 1650000 * (10**uint256(DECIMALS)); // 16.5% for Staking Revawards\n    uint256 public constant LIQUIDITY_POOL = 600000 * (10**uint256(DECIMALS)); // 6% for Liquidity pool\n    uint256 public constant ADVISORS = 850000 * (10**uint256(DECIMALS)); // 8.5% for Advisors\n    uint256 public constant SEED_INVESTMENT = 450000 * (10**uint256(DECIMALS)); // 4.5% for Seed investment\n    uint256 public constant PRIVATE_SALE = 2000000 * (10**uint256(DECIMALS)); // 20% for Private Sale\n    uint256 public constant TEAM_ALLOCATION = 1500000 * (10**uint256(DECIMALS)); // 15% for Team allocation\n\n    uint256 public constant LAUNCH_POOL =\n        5882352941 * (10**uint256(DECIMALS - 5)); // 58823.52941 for LaunchPool\n    uint256 public constant PUBLIC_SALE =\n        450000 * (10**uint256(DECIMALS)) + LAUNCH_POOL; // 4.5% for Public Sale\n    uint256 public constant STRATEGIC_ROUND =\n        1500000 * (10**uint256(DECIMALS)) - LAUNCH_POOL; // 15% for Strategic Round\n    uint256 public taxRate = 300;\n    address public taxationWallet;\n\n    bool private _isDistributionComplete = false;\n\n    mapping(address => bool) public taxExempt;\n\n    ILocker public override locker;\n\n    constructor() ERC20(NAME, SYMBOL) {\n        taxationWallet = _msgSender();\n\n        _mint(address(this), INITIAL_SUPPLY);\n    }\n\n    function setLocker(address _locker) external onlyOwner() {\n        require(_locker != address(0), \"_locker cannot be address(0)\");\n        locker = ILocker(_locker);\n        emit SetLocker(_locker);\n    }\n\n    function setDistributionTeamsAddresses(\n        address _CommunityDevelopmentAddr,\n        address _StakingRewardsAddr,\n        address _LiquidityPoolAddr,\n        address _PublicSaleAddr,\n        address _AdvisorsAddr,\n        address _SeedInvestmentAddr,\n        address _PrivateSaleAddr,\n        address _TeamAllocationAddr,\n        address _StrategicRoundAddr\n    ) public onlyOwner {\n        require(!_isDistributionComplete);\n\n        require(_CommunityDevelopmentAddr != address(0));\n        require(_StakingRewardsAddr != address(0));\n        require(_LiquidityPoolAddr != address(0));\n        require(_PublicSaleAddr != address(0));\n        require(_AdvisorsAddr != address(0));\n        require(_SeedInvestmentAddr != address(0));\n        require(_PrivateSaleAddr != address(0));\n        require(_TeamAllocationAddr != address(0));\n        require(_StrategicRoundAddr != address(0));\n        // set parnters addresses\n        CommunityDevelopmentAddr = _CommunityDevelopmentAddr;\n        StakingRewardsAddr = _StakingRewardsAddr;\n        LiquidityPoolAddr = _LiquidityPoolAddr;\n        PublicSaleAddr = _PublicSaleAddr;\n        AdvisorsAddr = _AdvisorsAddr;\n        SeedInvestmentAddr = _SeedInvestmentAddr;\n        PrivateSaleAddr = _PrivateSaleAddr;\n        TeamAllocationAddr = _TeamAllocationAddr;\n        StrategicRoundAddr = _StrategicRoundAddr;\n    }\n\n    function distributeTokens() public onlyOwner {\n        require((!_isDistributionComplete));\n\n        _transfer(\n            address(this),\n            CommunityDevelopmentAddr,\n            COMMUNITY_DEVELOPMENT\n        );\n        _transfer(address(this), StakingRewardsAddr, STAKING_REWARDS);\n        _transfer(address(this), LiquidityPoolAddr, LIQUIDITY_POOL);\n        _transfer(address(this), PublicSaleAddr, PUBLIC_SALE);\n        _transfer(address(this), AdvisorsAddr, ADVISORS);\n        _transfer(address(this), SeedInvestmentAddr, SEED_INVESTMENT);\n        _transfer(address(this), PrivateSaleAddr, PRIVATE_SALE);\n        _transfer(address(this), TeamAllocationAddr, TEAM_ALLOCATION);\n        _transfer(address(this), StrategicRoundAddr, STRATEGIC_ROUND);\n\n        // Whitelist these addresses as tex exempt\n        setTaxExemptStatus(CommunityDevelopmentAddr, true);\n        setTaxExemptStatus(StakingRewardsAddr, true);\n        setTaxExemptStatus(LiquidityPoolAddr, true);\n        setTaxExemptStatus(PublicSaleAddr, true);\n        setTaxExemptStatus(AdvisorsAddr, true);\n        setTaxExemptStatus(SeedInvestmentAddr, true);\n        setTaxExemptStatus(PrivateSaleAddr, true);\n        setTaxExemptStatus(TeamAllocationAddr, true);\n        setTaxExemptStatus(StrategicRoundAddr, true);\n\n        _isDistributionComplete = true;\n    }\n\n    function setTaxRate(uint256 newTaxRate) public onlyOwner {\n        require(newTaxRate < 10000, \"Tax connot be over 100% (10000 BP)\");\n        taxRate = newTaxRate;\n    }\n\n    function setTaxExemptStatus(address account, bool status) public onlyOwner {\n        require(account != address(0));\n        taxExempt[account] = status;\n    }\n\n    function setTaxationWallet(address newTaxationWallet) public onlyOwner {\n        require(newTaxationWallet != address(0));\n        taxationWallet = newTaxationWallet;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual override {\n        if (address(locker) != address(0)) {\n            locker.lockOrGetPenalty(sender, recipient);\n        }\n        ERC20._transfer(sender, recipient, amount);\n    }\n\n    function _transferWithTax(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(sender != recipient, \"Cannot self transfer\");\n\n        uint256 tax = amount.mulBP(taxRate);\n        uint256 tokensToTransfer = amount.sub(tax);\n\n        _transfer(sender, taxationWallet, tax);\n        _transfer(sender, recipient, tokensToTransfer);\n    }\n\n    function transfer(address recipient, uint256 amount)\n        public\n        override\n        returns (bool)\n    {\n        require(_msgSender() != recipient, \"ERC20: cannot self transfer\");\n        !taxExempt[_msgSender()]\n            ? _transferWithTax(_msgSender(), recipient, amount)\n            : _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        !taxExempt[sender]\n            ? _transferWithTax(sender, recipient, amount)\n            : _transfer(sender, recipient, amount);\n\n        approve(\n            _msgSender(),\n            allowance(sender, _msgSender()).sub(\n                amount,\n                \"Transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/interfaces/ILocker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface ILocker {\n    /**\n     * @dev Fails if transaction is not allowed.\n     * Return values can be ignored for AntiBot launches\n     */\n    function lockOrGetPenalty(address source, address dest)\n        external\n        returns (bool, uint256);\n}\n\ninterface ILockerUser {\n    function locker() external view returns (ILocker);\n\n    /**\n     * @dev Emitted when setLocker is called.\n     */\n    event SetLocker(address indexed locker);\n}\n\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/Test/TotemVesting/TeamVesting.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./TotemVesting.sol\";\n\ncontract TeamVesting is TotemVesting {\n    uint256 public constant TOTAL_AMOUNT = 1500000 * (10**18);\n    uint256 public constant WITHDRAW_INTERVAL = 30 days;\n    uint256 public constant RELEASE_PERIODS = 12;\n    uint256 public constant LOCK_PERIODS = 6;\n\n    constructor(TotemToken _totemToken)\n        TotemVesting(\n            _totemToken,\n            TOTAL_AMOUNT,\n            WITHDRAW_INTERVAL,\n            RELEASE_PERIODS,\n            LOCK_PERIODS\n        )\n    {}\n}\n"
    },
    "contracts/Test/TotemVesting/StrategicVesting.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./TotemVesting.sol\";\n\ncontract StrategicVesting is TotemVesting {\n    uint256 public constant TOTAL_AMOUNT = 1500000 * (10**18);\n    uint256 public constant WITHDRAW_INTERVAL = 30 days;\n    uint256 public constant RELEASE_PERIODS = 5;\n    uint256 public constant LOCK_PERIODS = 0;\n\n    constructor(TotemToken _totemToken)\n        TotemVesting(\n            _totemToken,\n            TOTAL_AMOUNT,\n            WITHDRAW_INTERVAL,\n            RELEASE_PERIODS,\n            LOCK_PERIODS\n        )\n    {}\n}\n"
    },
    "contracts/Test/TotemVesting/SeedVesting.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./TotemVesting.sol\";\n\ncontract SeedVesting is TotemVesting {\n    uint256 public constant TOTAL_AMOUNT = 450000 * (10**18);\n    uint256 public constant WITHDRAW_INTERVAL = 30 days;\n    uint256 public constant RELEASE_PERIODS = 9;\n    uint256 public constant LOCK_PERIODS = 3;\n\n    constructor(TotemToken _totemToken)\n        TotemVesting(\n            _totemToken,\n            TOTAL_AMOUNT,\n            WITHDRAW_INTERVAL,\n            RELEASE_PERIODS,\n            LOCK_PERIODS\n        )\n    {}\n}\n"
    },
    "contracts/Test/TotemVesting/CommunityVesting.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./TotemVesting.sol\";\n\ncontract CommunityVesting is TotemVesting {\n    uint256 public constant TOTAL_AMOUNT = 1000000 * (10**18);\n    uint256 public constant WITHDRAW_INTERVAL = 30 days;\n    uint256 public constant RELEASE_PERIODS = 36;\n    uint256 public constant LOCK_PERIODS = 0;\n\n    constructor(TotemToken _totemToken)\n        TotemVesting(\n            _totemToken,\n            TOTAL_AMOUNT,\n            WITHDRAW_INTERVAL,\n            RELEASE_PERIODS,\n            LOCK_PERIODS\n        )\n    {}\n}\n"
    },
    "contracts/Test/TotemTokenManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./TotemToken.sol\";\nimport \"../Role/Roles.sol\";\n\ncontract TotemTokenManager is Context, Ownable {\n\n    TotemToken totemToken;\n\n    using Roles for Roles.Role;\n\n    Roles.Role private _managers;\n\n    event ManagerAdded(address indexed account);\n    event ManagerRemoved(address indexed account);\n\n    constructor(TotemToken _totemToken) {\n        if (!isManager(_msgSender())) {\n            _addManager(_msgSender());\n        }\n\n        totemToken = _totemToken;\n    }\n\n    modifier onlyManager() {\n        require(\n            isManager(_msgSender()),\n            \"0100 caller does not have the Manager role\"\n        );\n        _;\n    }\n\n    function isManager(address account) public view returns (bool) {\n        return _managers.has(account);\n    }\n\n    function addManager(address account) public onlyOwner {\n        _addManager(account);\n    }\n\n    function removeManager(address account) public onlyOwner {\n        _removeManager(account);\n    }\n\n    function renounceManager() public {\n        _removeManager(_msgSender());\n    }\n\n    function _addManager(address account) internal {\n        _managers.add(account);\n        emit ManagerAdded(account);\n    }\n\n    function _removeManager(address account) internal {\n        _managers.remove(account);\n        emit ManagerRemoved(account);\n    }\n\n    function setLocker(address _locker) external onlyOwner {\n        totemToken.setLocker(_locker);\n    }\n\n    function setDistributionTeamsAddresses(\n        address _CommunityDevelopmentAddr,\n        address _StakingRewardsAddr,\n        address _LiquidityPoolAddr,\n        address _PublicSaleAddr,\n        address _AdvisorsAddr,\n        address _SeedInvestmentAddr,\n        address _PrivateSaleAddr,\n        address _TeamAllocationAddr,\n        address _StrategicRoundAddr\n    ) public onlyOwner {\n        totemToken.setDistributionTeamsAddresses(\n            _CommunityDevelopmentAddr,\n            _StakingRewardsAddr,\n            _LiquidityPoolAddr,\n            _PublicSaleAddr,\n            _AdvisorsAddr,\n            _SeedInvestmentAddr,\n            _PrivateSaleAddr,\n            _TeamAllocationAddr,\n            _StrategicRoundAddr\n        );\n    }\n\n    function distributeTokens() public onlyOwner {\n        totemToken.distributeTokens();\n    }\n\n    function setTaxRate(uint256 newTaxRate) public onlyOwner {\n        totemToken.setTaxRate(newTaxRate);\n    }\n\n    function setTaxExemptStatus(address account, bool status) public onlyManager {\n        totemToken.setTaxExemptStatus(account, status);\n    }\n\n    function setTaxationWallet(address newTaxationWallet) public onlyOwner {\n        totemToken.setTaxationWallet(newTaxationWallet);\n    }\n\n\n    function renounceOwnership() public override onlyOwner {\n        // renounceOwnership is over written and do nothing\n    }\n\n    function totemTokenTransferOwnership(address newOwner) public onlyOwner {\n        totemToken.transferOwnership(newOwner);\n    }\n}"
    },
    "contracts/Role/Rewarder.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport \"./Roles.sol\";\n\ncontract Rewarder is Context {\n    using Roles for Roles.Role;\n\n    event RewarderAdded(address indexed account);\n    event RewarderRemoved(address indexed account);\n\n    Roles.Role private _rewarders;\n\n    constructor() {\n        if (!isRewarder(_msgSender())) {\n            _addRewarder(_msgSender());\n        }\n    }\n\n    modifier onlyRewarder() {\n        require(\n            isRewarder(_msgSender()),\n            \"RewarderRole: caller does not have the Rewarder role\"\n        );\n        _;\n    }\n\n    function isRewarder(address account) public view returns (bool) {\n        return _rewarders.has(account);\n    }\n\n    function addRewarder(address account) public onlyRewarder {\n        _addRewarder(account);\n    }\n\n    function renounceRewarder() public {\n        _removeRewarder(_msgSender());\n    }\n\n    function _addRewarder(address account) internal {\n        _rewarders.add(account);\n        emit RewarderAdded(account);\n    }\n\n    function _removeRewarder(address account) internal {\n        _rewarders.remove(account);\n        emit RewarderRemoved(account);\n    }\n}\n"
    },
    "contracts/Test/RewardManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"./TotemToken.sol\";\nimport \"../Role/Operator.sol\";\nimport \"../Role/Rewarder.sol\";\n\ncontract RewardManager is Context, Ownable, Operator, Rewarder {\n    TotemToken totemToken;\n\n    event SetOperator(address operator);\n    event SetRewarder(address rewarder);\n\n    constructor(TotemToken _totemToken) {\n        totemToken = _totemToken;\n    }\n\n    function setOperator(address _newOperator) public onlyOwner {\n        require(\n            _newOperator != address(0),\n            \"0200 New Operator address cannot be zero.\"\n        );\n\n        addOperator(_newOperator);\n        emit SetOperator(_newOperator);\n    }\n\n    function addPool(address _poolAddress) public {\n        require(\n            _poolAddress != address(0),\n            \"0210 Pool address cannot be zero.\"\n        );\n\n//        addRewarder(_poolAddress);\n        emit SetRewarder(_poolAddress);\n    }\n\n    function rewardUser(address _user, uint256 _amount) public onlyRewarder {\n        require(_user != address(0), \"0230 User address cannot be zero.\");\n\n        require(totemToken.transfer(_user, _amount));\n    }\n}\n"
    },
    "contracts/Role/Operator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport \"./Roles.sol\";\n\ncontract Operator is Context {\n    using Roles for Roles.Role;\n\n    event OperatorAdded(address indexed account);\n    event OperatorRemoved(address indexed account);\n\n    Roles.Role private _operators;\n\n    constructor() {\n        if (!isOperator(_msgSender())) {\n            _addOperator(_msgSender());\n        }\n    }\n\n    modifier onlyOperator() {\n        require(\n            isOperator(_msgSender()),\n            \"OperatorRole: caller does not have the Operator role\"\n        );\n        _;\n    }\n\n    function isOperator(address account) public view returns (bool) {\n        return _operators.has(account);\n    }\n\n    function addOperator(address account) public onlyOperator {\n        _addOperator(account);\n    }\n\n    function renounceOperator() public {\n        _removeOperator(_msgSender());\n    }\n\n    function _addOperator(address account) internal {\n        _operators.add(account);\n        emit OperatorAdded(account);\n    }\n\n    function _removeOperator(address account) internal {\n        _operators.remove(account);\n        emit OperatorRemoved(account);\n    }\n}\n"
    },
    "contracts/Test/WrappedERC20Token2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract WrappedERC20Token2 is Context, ERC20, Ownable {\n    using SafeMath for uint256;\n\n    constructor(string memory NAME, string memory SYMBOL) ERC20(NAME, SYMBOL) {\n        _mint(_msgSender(), 100000000000000000000000);\n    }\n}\n"
    },
    "contracts/Test/WrappedERC20Token.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract WrappedERC20Token is Context, ERC20, Ownable {\n    using SafeMath for uint256;\n\n    constructor(string memory NAME, string memory SYMBOL) ERC20(NAME, SYMBOL) {\n        _mint(_msgSender(), 100000000000000000000000);\n    }\n}\n"
    },
    "contracts/Test/TotemVesting/AdvisorsVesting.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./TotemVesting.sol\";\n\ncontract AdvisorsVesting is TotemVesting {\n    uint256 public constant TOTAL_AMOUNT = 850000 * (10**18);\n    uint256 public constant WITHDRAW_INTERVAL = 30 days;\n    uint256 public constant RELEASE_PERIODS = 12;\n    uint256 public constant LOCK_PERIODS = 0;\n\n    constructor(TotemToken _totemToken)\n        TotemVesting(\n            _totemToken,\n            TOTAL_AMOUNT,\n            WITHDRAW_INTERVAL,\n            RELEASE_PERIODS,\n            LOCK_PERIODS\n        )\n    {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}